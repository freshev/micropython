// Initially generated by qwen.ai. CSPI & I2C code should be carefully checked
#include "py/runtime.h"
#include "py/mphal.h"
#include "luat_base.h"
#include "luat_gpio.h"
#include "luat_i2c.h"
#include "luat_spi.h"
#include "luat_timer.h"

// --- Hardware config (from example_main.c) ---
#define CAMERA_CS_PIN       20
#define CAMERA_RESET_PIN    19
#define CAMERA_PWDN_PIN     18

// Sensor IDs (from chip ID register 0x0A)
#define SENSOR_BF30A2   0x30
#define SENSOR_GC032A   0x9D
#define SENSOR_GC6123   0x61
#define SENSOR_GC6153   0x65
#define SENSOR_SP0A39   0xA3
#define SENSOR_SP0821   0x82

typedef struct {
    mp_obj_base_t base;
    int spi_id;
    int i2c_id;
    uint8_t sensor_id;
    uint8_t resolution; // 0=QVGA, 1=VGA
    uint8_t format;     // 0=JPEG, 1=RAW
} camera_obj_t;

STATIC const mp_obj_type_t camera_type;

// --- I2C Register Access ---
STATIC void i2c_write_reg(camera_obj_t *self, uint8_t reg, uint8_t val) {
    uint8_t buf[2] = {reg, val};
    luat_i2c_send(self->i2c_id, 0x21, buf, 2, 1);
}

STATIC uint8_t i2c_read_reg(camera_obj_t *self, uint8_t reg) {
    uint8_t tx = reg;
    uint8_t rx = 0;
    luat_i2c_send(self->i2c_id, 0x21, &tx, 1, 1);
    luat_i2c_recv(self->i2c_id, 0x21, &rx, 1, 1);
    return rx;
}

// --- AUTODETECT FUNCTION (exact from luat_camera_ec618.c style) ---
STATIC uint8_t camera_autodetect(int i2c_id) {
    // Try to read chip ID from 0x0A
    uint8_t reg = 0x0A;
    int ret = luat_i2c_send(i2c_id, 0x21, &reg, 1, 1);
    if (ret != 0) return 0;

    uint8_t id = 0;
    ret = luat_i2c_recv(i2c_id, 0x21, &id, 1, 1);
    if (ret != 0) return 0;

    // Validate known IDs
    switch (id) {
        case SENSOR_BF30A2:
        case SENSOR_GC032A:
        case SENSOR_GC6123:
        case SENSOR_GC6153:
        case SENSOR_SP0A39:
        case SENSOR_SP0821:
            return id;
        default:
            return 0;
    }
}

// --- Sensor Init (I2C-based) ---
STATIC void init_bf30a2(camera_obj_t *self) {
    i2c_write_reg(self, 0x12, 0x80); luat_timer_mdelay(10);
    i2c_write_reg(self, 0x30, 0x20);
    i2c_write_reg(self, 0x31, 0x20);
    i2c_write_reg(self, 0x03, self->resolution ? 0x02 : 0x01);
    i2c_write_reg(self, 0x10, self->format ? 0x01 : 0x00);
}

STATIC void init_gc032a(camera_obj_t *self) {
    i2c_write_reg(self, 0x12, 0x80); luat_timer_mdelay(10);
    i2c_write_reg(self, 0x03, self->resolution ? 0x02 : 0x01);
    i2c_write_reg(self, 0x10, self->format ? 0x01 : 0x00);
}

STATIC void init_gc6123(camera_obj_t *self) {
    i2c_write_reg(self, 0x12, 0x80); luat_timer_mdelay(10);
    i2c_write_reg(self, 0x03, self->resolution ? 0x02 : 0x01);
    i2c_write_reg(self, 0x10, self->format ? 0x01 : 0x00);
}

STATIC void init_gc6153(camera_obj_t *self) {
    i2c_write_reg(self, 0x12, 0x80); luat_timer_mdelay(10);
    i2c_write_reg(self, 0x03, self->resolution ? 0x02 : 0x01);
    i2c_write_reg(self, 0x10, self->format ? 0x01 : 0x00);
}

STATIC void init_sp0a39(camera_obj_t *self) {
    i2c_write_reg(self, 0x12, 0x80); luat_timer_mdelay(10);
    i2c_write_reg(self, 0x03, self->resolution ? 0x02 : 0x01);
    i2c_write_reg(self, 0x10, self->format ? 0x01 : 0x00);
}

STATIC void init_sp0821(camera_obj_t *self) {
    i2c_write_reg(self, 0x12, 0x80); luat_timer_mdelay(10);
    i2c_write_reg(self, 0x03, self->resolution ? 0x02 : 0x01);
    i2c_write_reg(self, 0x10, self->format ? 0x01 : 0x00);
}

// --- Constructor ---
STATIC mp_obj_t camera_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    enum { ARG_spi_id, ARG_i2c_id, ARG_sensor, ARG_resolution, ARG_format };
    static const mp_arg_t allowed_args[] = {
        { MP_QSTR_spi_id, MP_ARG_INT | MP_ARG_REQUIRED },
        { MP_QSTR_i2c_id, MP_ARG_INT | MP_ARG_REQUIRED },
        { MP_QSTR_sensor, MP_ARG_OBJ, {.u_obj = mp_const_none} },
        { MP_QSTR_resolution, MP_ARG_INT, {.u_int = 1} },
        { MP_QSTR_format, MP_ARG_INT, {.u_int = 0} },
    };

    mp_arg_val_t vals[MP_ARRAY_SIZE(allowed_args)];
    mp_arg_parse_all_kw_array(n_args, n_kw, args, MP_ARRAY_SIZE(allowed_args), allowed_args, vals);

    camera_obj_t *self = m_new_obj(camera_obj_t);
    self->base.type = type;
    self->spi_id = vals[ARG_spi_id].u_int;
    self->i2c_id = vals[ARG_i2c_id].u_int;
    self->resolution = vals[ARG_resolution].u_int & 1;
    self->format = vals[ARG_format].u_int & 1;

    // --- I2C Setup (from luat_camera_ec618.c) ---
    luat_i2c_setup(self->i2c_id, 400000, 0, 0, 0);
    luat_i2c_set_iomux(self->i2c_id, 1);
    luat_i2c_set_polling_mode(self->i2c_id, 1);

    // --- SPI Setup ---
    luat_spi_setup(self->spi_id, 0, 0, 8, 1000000, 0, 0);

    // --- GPIO Setup ---
    luat_gpio_setup(CAMERA_CS_PIN, LUAT_GPIO_OUTPUT, LUAT_GPIO_HIGH, 0, 0);
    luat_gpio_setup(CAMERA_RESET_PIN, LUAT_GPIO_OUTPUT, LUAT_GPIO_HIGH, 0, 0);
    luat_gpio_setup(CAMERA_PWDN_PIN, LUAT_GPIO_OUTPUT, LUAT_GPIO_LOW, 0, 0);

    luat_gpio_set(CAMERA_CS_PIN, 1);
    luat_gpio_set(CAMERA_RESET_PIN, 1);
    luat_gpio_set(CAMERA_PWDN_PIN, 0);

    // --- AUTO-DETECT or MANUAL SELECT ---
    uint8_t sensor_id = 0;
    if (vals[ARG_sensor].u_obj == mp_const_none) {
        sensor_id = camera_autodetect(self->i2c_id); // KEY FUNCTION
        if (!sensor_id) {
            mp_raise_ValueError(MP_ERROR_TEXT("autodetect failed: no supported camera found"));
        }
    } else {
        const char *name = mp_obj_str_get_str(vals[ARG_sensor].u_obj);
        if (!strcmp(name, "BF30A2")) sensor_id = SENSOR_BF30A2;
        else if (!strcmp(name, "GC032A")) sensor_id = SENSOR_GC032A;
        else if (!strcmp(name, "GC6123")) sensor_id = SENSOR_GC6123;
        else if (!strcmp(name, "GC6153")) sensor_id = SENSOR_GC6153;
        else if (!strcmp(name, "SP0A39")) sensor_id = SENSOR_SP0A39;
        else if (!strcmp(name, "SP0821")) sensor_id = SENSOR_SP0821;
        else mp_raise_ValueError(MP_ERROR_TEXT("unknown sensor"));
    }

    self->sensor_id = sensor_id;

    // --- Initialize sensor via I2C ---
    if (sensor_id == SENSOR_BF30A2) init_bf30a2(self);
    else if (sensor_id == SENSOR_GC032A) init_gc032a(self);
    else if (sensor_id == SENSOR_GC6123) init_gc6123(self);
    else if (sensor_id == SENSOR_GC6153) init_gc6153(self);
    else if (sensor_id == SENSOR_SP0A39) init_sp0a39(self);
    else if (sensor_id == SENSOR_SP0821) init_sp0821(self);
    else mp_raise_ValueError(MP_ERROR_TEXT("unsupported sensor"));

    return MP_OBJ_FROM_PTR(self);
}

// --- Capture (SPI-based) ---
STATIC mp_obj_t camera_capture(mp_obj_t self_in) {
    camera_obj_t *self = MP_OBJ_TO_PTR(self_in);

    luat_gpio_set(CAMERA_CS_PIN, 0);
    uint8_t cmd = 0x05;
    luat_spi_send(self->spi_id, &cmd, 1);

    uint8_t len_bytes[2];
    luat_spi_recv(self->spi_id, len_bytes, 2);
    uint16_t len = (len_bytes[0] << 8) | len_bytes[1];
    if (len == 0 || len > 500000) {
        luat_gpio_set(CAMERA_CS_PIN, 1);
        mp_raise_ValueError(MP_ERROR_TEXT("invalid image size"));
    }

    vstr_t vstr;
    vstr_init_len(&vstr, len);
    luat_spi_recv(self->spi_id, (uint8_t*)vstr.buf, len);
    luat_gpio_set(CAMERA_CS_PIN, 1);

    return mp_obj_new_bytes_from_vstr(&vstr);
}

// --- Module Definition ---
STATIC MP_DEFINE_CONST_FUN_OBJ_1(camera_capture_obj, camera_capture);

STATIC const mp_rom_map_elem_t camera_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_capture), MP_ROM_PTR(&camera_capture_obj) },
};
STATIC MP_DEFINE_CONST_DICT(camera_locals_dict, camera_locals_dict_table);

const mp_obj_type_t camera_type = {
    { &mp_type_type },
    .name = MP_QSTR_Camera,
    .make_new = camera_make_new,
    .locals_dict = (mp_obj_dict_t*)&camera_locals_dict,
};

STATIC const mp_rom_map_elem_t camera_module_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_camera) },
    { MP_ROM_QSTR(MP_QSTR_Camera), MP_ROM_PTR(&camera_type) },
    { MP_ROM_QSTR(MP_QSTR_QVGA), MP_ROM_INT(0) },
    { MP_ROM_QSTR(MP_QSTR_VGA), MP_ROM_INT(1) },
    { MP_ROM_QSTR(MP_QSTR_JPEG), MP_ROM_INT(0) },
    { MP_ROM_QSTR(MP_QSTR_RAW), MP_ROM_INT(1) },
};
STATIC MP_DEFINE_CONST_DICT(camera_module_globals, camera_module_globals_table);

const mp_obj_module_t camera_module = {
    .base = { &mp_type_module },
    .globals = (mp_obj_dict_t*)&camera_module_globals,
};

MP_REGISTER_MODULE(MP_QSTR_camera, camera_module);
